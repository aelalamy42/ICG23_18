ICG GL2 - Meshes in the GPU pipeline
Group 18: Ahmed Elalamy, Alexandra Lagutova

Task GL2.1.1: Compute triangle normals and opening angles

For this first task, we went through all of the faces of our triangles, we computed the normal vector to each triangle in the mesh, by at first taking the cross product between the lines p(Vi2) - p(Vi1) and  p(Vi3) - p(Vi1), which we deduced by using the right hand rule. We are going to push the result into the array tri_normals. 
Then we compute the weights for each vert of a triagle, by substucting one by one the crossing between the two lines and then computing the angle between them. For example for the weight of the vertex 2, we computed the angle between p(Vi3) - p(Vi2) and p(Vi1) - p(Vi2). Then we store the result in angle_weights. 

Task GL2.1.2: Compute vertex normals

For this task, we use the formula given to us in the handout.
We go through all the triangles in the mesh and it's faces and compute the contribution of each weight to the vertex normals, by adding the contribution to the vertex_normal at it's corresponding vertex index. One important thing for this computation is to normalize the contribution before adding it, by using the function scale on the weight with the normal.

Task GL2.2.1: Pass normals to fragment shader

To start this task, we added the line 213 to the mesh_render.js which does the computation of the model-view-projection matrix mat_mvp that we did last week.
Then we created varying variables vertex_to_fragment in the vertex and fragment shader files. In the vertex shader we assigned this value to the normal of mat_normals_to_view * vertex_normal. We need to normalize, because a scaling could have been done wrong and invalid. 
In the normals shader we used this varying value to compute the color with the formula given to us in the handout. 

Task GL2.2.2: Transforming the normals

In this task, we calculated mat_model_view, and mat_normals_to_view, since we have already computed mat_mvp in the previous task. For mat_model_view, we at just did the multiplication of mat model and mat view, since it puts the model in the coordinates corresponding to the view.
Then we used the formula given to us, so we transformed mat4 into mat3 and did the transpose and the inversion.
Now to transform the normals to camera space, we multiplied mat_mvp by our vertex_position (which we had to transform to vec4 for the matrix multiplication to be correct)

Task GL2.3: Gouraud lighting

For the Gouraud lighting, we used the formula given to us in shade_pervertex.vert.js. We used material_color as the a material for every component (except ambient for which we used material_color * material_ambient as suggested). We also needed to compute the halway vecor foe this formula which we did by normalizing the position of the light (in camera space coordinates) - two times the vertex view. (to explain more ?)
Then we used this value in shade_pervertex.frag.js and displayed the color


Task GL2.4: Phong lighting

For the Phong lighting, we used the formula given to us in the handout. We used the same values as before for the materials. We computed the normal vector by taking the lighting vector - the view vector. And we substitued all the other values in the formula. 